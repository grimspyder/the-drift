<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Drift ‚Äî Map Editor</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box }
    body { font-family: 'Segoe UI', system-ui, sans-serif; background: #1a1a2e; color: #e0e0e0; height: 100vh; overflow: hidden }

    header { background: #16213e; padding: 10px 20px; border-bottom: 2px solid #0f3460; display: flex; align-items: center; gap: 16px }
    header h1 { font-size: 1.2rem; color: #e94560 }
    header span { color: #666; font-size: .8rem }

    .app { display: flex; height: calc(100vh - 48px) }

    /* Left panel */
    .palette-panel { width: 220px; background: #16213e; padding: 12px; overflow-y: auto; border-right: 1px solid #0f3460; flex-shrink: 0 }
    .palette-panel h3 { font-size: .78rem; color: #e94560; margin: 12px 0 6px; text-transform: uppercase; letter-spacing: 1px }
    .palette-panel h3:first-child { margin-top: 0 }

    .upload-box { background: #0f2040; border: 1px solid #2a5a8a; border-radius: 6px; padding: 10px; margin-bottom: 4px }
    .upload-box input[type=file] { width: 100%; color: #ccc; font-size: .72rem; margin-bottom: 8px }
    .hint { font-size: .65rem; color: #778; margin-bottom: 8px; line-height: 1.4 }
    .threshold-row { display: flex; align-items: center; gap: 6px; font-size: .65rem; color: #aaa; margin-bottom: 6px }
    .threshold-row input[type=range] { flex: 1 }
    .threshold-row span { color: #4fc3f7; width: 24px; text-align: right }

    .tile-btn { display: flex; align-items: center; gap: 8px; width: 100%; padding: 7px 10px; background: #0f3460; border: 2px solid transparent; border-radius: 6px; color: #ccc; cursor: pointer; font-size: .78rem; margin-bottom: 4px; transition: all .15s; text-align: left }
    .tile-btn:hover { background: #1a4a80; color: #fff }
    .tile-btn.active { border-color: #e94560; background: #2a1530; color: #fff }
    .tile-btn .icon { font-size: 1rem; width: 20px; text-align: center; flex-shrink: 0 }
    .tile-btn .info { font-size: .62rem; color: #556; margin-left: auto }

    .legend { background: #0a0a1a; border-radius: 5px; padding: 8px; font-size: .65rem; line-height: 1.8; color: #556 }
    .legend b { color: #888 }

    /* Center canvas */
    .canvas-area { flex: 1; display: flex; flex-direction: column; overflow: hidden }
    .toolbar { display: flex; gap: 8px; padding: 8px 12px; background: #11192e; align-items: center; flex-wrap: wrap; border-bottom: 1px solid #0f3460 }
    .toolbar label { font-size: .75rem; color: #aaa }
    .toolbar select, .toolbar input[type=text] { background: #0f3460; color: #e0e0e0; border: 1px solid #333; padding: 4px 8px; border-radius: 4px; font-size: .75rem }
    .canvas-viewport { flex: 1; overflow: auto; background: #050508; cursor: crosshair; position: relative }
    .canvas-viewport canvas { display: block; image-rendering: pixelated }
    .status-bar { padding: 5px 12px; background: #0a0a15; font-size: .7rem; color: #4fc3f7; border-top: 1px solid #0f3460 }

    /* Tool buttons */
    .tool-btn { padding: 5px 12px; background: #0f3460; color: #aaa; border: 1px solid #333; border-radius: 6px; cursor: pointer; font-size: .75rem; font-weight: 600; transition: all .15s }
    .tool-btn:hover { background: #1a4a80; color: #fff }
    .tool-btn.active { background: #e94560; color: #fff; border-color: #e94560 }
    .save-btn { background: #0a2e0a; color: #4caf50; border-color: #4caf50 }
    .save-btn:hover { background: #4caf50; color: #000 }
    .load-btn { background: #0f3460; color: #4fc3f7; border-color: #4fc3f7 }
    .load-btn:hover { background: #4fc3f7; color: #000 }
    .trace-btn { width: 100%; padding: 7px; background: #1a4a20; color: #66cc77; border: 1px solid #4caf50; border-radius: 4px; font-size: .75rem; cursor: pointer; margin-top: 4px; display: none }
    .trace-btn:hover { background: #4caf50; color: #000 }

    /* Right info panel */
    .info-panel { width: 190px; background: #16213e; padding: 12px; overflow-y: auto; border-left: 1px solid #0f3460; flex-shrink: 0 }
    .info-panel h3 { font-size: .78rem; color: #e94560; margin: 10px 0 5px; text-transform: uppercase }
    .info-panel h3:first-child { margin-top: 0 }
    .info-box { background: #0a0a1a; border-radius: 5px; padding: 8px; margin-bottom: 8px; font-size: .72rem; line-height: 1.6 }
    .info-box .lbl { color: #778 }
    .info-box .val { color: #4fc3f7; font-family: Consolas, monospace }
    .minimap { width: 100%; aspect-ratio: 16/10; background: #111; border-radius: 4px; margin-bottom: 8px; overflow: hidden }
    .minimap canvas { width: 100%; height: 100%; image-rendering: pixelated }

    /* Modal */
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,.75); z-index: 100; display: none; align-items: center; justify-content: center }
    .modal-overlay.show { display: flex }
    .modal { background: #16213e; border: 1px solid #0f3460; border-radius: 10px; padding: 20px; min-width: 340px; max-height: 80vh; overflow-y: auto }
    .modal h2 { color: #e94560; font-size: 1rem; margin-bottom: 12px }
    .modal-list { list-style: none }
    .modal-list li { padding: 8px 10px; background: #0f3460; margin-bottom: 4px; border-radius: 4px; cursor: pointer; font-size: .78rem }
    .modal-list li:hover { background: #1a4a80 }
    .modal-close { margin-top: 12px; padding: 6px 16px; background: #333; color: #ccc; border: none; border-radius: 4px; cursor: pointer }
  </style>
</head>

<body>
  <header>
    <h1>üó∫Ô∏è The Drift ‚Äî Map Editor</h1>
    <span>Upload a map image ¬∑ Paint walkable areas ¬∑ Place markers ¬∑ Save</span>
  </header>

  <div class="app">

    <!-- LEFT: Controls -->
    <div class="palette-panel">

      <h3>üì§ Map Image</h3>
      <div class="upload-box">
        <input type="file" id="mapImageUpload" accept="image/*" onchange="handleMapImageUpload(event)">
        <div class="hint">Upload any image. It becomes the visual map. Then paint which areas the player can walk.</div>
        <div class="threshold-row">
          <span>Threshold:</span>
          <input type="range" id="traceThreshold" min="32" max="224" value="128" onchange="updateTracePreview()">
          <span id="thresholdVal">128</span>
        </div>
        <button class="trace-btn" id="traceBtn" onclick="traceFromImage()">üéØ Auto-Trace (light = floor)</button>
      </div>

      <h3>üñåÔ∏è Paint Mode</h3>
      <button class="tile-btn active" id="btnFloor" onclick="selectMode('floor')">
        <span class="icon">üü©</span>Walkable Floor
      </button>
      <button class="tile-btn" id="btnSolid" onclick="selectMode('solid')">
        <span class="icon">üü•</span>Wall / Solid
      </button>

      <h3>üìç Markers</h3>
      <button class="tile-btn" data-special="start" onclick="selectSpecial('start')">
        <span class="icon">üü¢</span>Player Start<span class="info">1 only</span>
      </button>
      <button class="tile-btn" data-special="exit" onclick="selectSpecial('exit')">
        <span class="icon">üåÄ</span>Exit Portal<span class="info">1 only</span>
      </button>
      <button class="tile-btn" data-special="enemy" onclick="selectSpecial('enemy')">
        <span class="icon">üëπ</span>Enemy Spawn<span class="info">0+</span>
      </button>

      <h3>üóëÔ∏è Eraser</h3>
      <button class="tile-btn" id="btnErase" onclick="selectMode('erase')">
        <span class="icon">‚¨õ</span>Void / Erase
      </button>

      <div class="legend" style="margin-top:10px">
        <b>Legend:</b><br>
        üü© Clear = floor (walkable)<br>
        üü• Dimmed = wall (solid)<br>
        ‚¨õ Black = void (nothing)
      </div>

    </div>

    <!-- CENTER: Canvas -->
    <div class="canvas-area">
      <div class="toolbar">

        <label>Grid:</label>
        <select id="mapSize" onchange="resizeMap()">
          <option value="25,18">Small (25√ó18)</option>
          <option value="35,22" selected>Medium (35√ó22)</option>
          <option value="45,28">Large (45√ó28)</option>
          <option value="60,38">Epic (60√ó38)</option>
        </select>

        <label>World:</label>
        <select id="worldId">
          <option value="0">0 - Prime</option>
          <option value="1">1 - Verdant</option>
          <option value="2">2 - Arid</option>
          <option value="3">3 - Crystal</option>
          <option value="4">4 - Ashen</option>
          <option value="5">5 - Shadow</option>
        </select>

        <label>Name:</label>
        <input type="text" id="mapName" value="Prime World - Level 1" style="width:160px">

        <div style="margin-left:auto;display:flex;gap:6px">
          <button class="tool-btn active" data-tool="paint" onclick="setTool('paint')">üñåÔ∏è Paint</button>
          <button class="tool-btn" data-tool="fill" onclick="setTool('fill')">ü™£ Fill</button>
          <button class="tool-btn" data-tool="rect" onclick="setTool('rect')">‚¨ú Rect</button>
        </div>

        <div style="display:flex;gap:6px">
          <button class="tool-btn" onclick="undo()">‚Ü©Ô∏è</button>
          <button class="tool-btn" onclick="redo()">‚Ü™Ô∏è</button>
        </div>

        <div style="display:flex;gap:6px">
          <button class="tool-btn save-btn" onclick="saveMap()">üíæ Save</button>
          <button class="tool-btn load-btn" onclick="showLoadModal()">üìÇ Load</button>
        </div>

      </div>

      <div class="canvas-viewport" id="viewport">
        <canvas id="mapCanvas"></canvas>
      </div>

      <div class="status-bar" id="statusBar">Upload an image or paint the grid. Place Player Start and Exit Portal before saving.</div>
    </div>

    <!-- RIGHT: Info -->
    <div class="info-panel">

      <h3>Current Mode</h3>
      <div class="info-box">
        <div><span class="lbl">Painting:</span> <span class="val" id="infoMode">floor</span></div>
        <div><span class="lbl">Tool:</span> <span class="val" id="infoTool">paint</span></div>
      </div>

      <h3>Map Stats</h3>
      <div class="info-box">
        <div><span class="lbl">Grid:</span> <span class="val" id="statsSize">35√ó22</span></div>
        <div><span class="lbl">Floor cells:</span> <span class="val" id="statsFloors">0</span></div>
        <div><span class="lbl">Player Start:</span> <span class="val" id="statsStart">‚ùå</span></div>
        <div><span class="lbl">Exit Portal:</span> <span class="val" id="statsExit">‚ùå</span></div>
        <div><span class="lbl">Enemy Spawns:</span> <span class="val" id="statsEnemies">0</span></div>
      </div>

      <h3>Mini Map</h3>
      <div class="minimap">
        <canvas id="minimapCanvas"></canvas>
      </div>

      <h3>Keyboard</h3>
      <div class="info-box" style="font-size:.65rem;color:#556;line-height:1.8">
        <div>Ctrl+Z / Y ‚Äî Undo/Redo</div>
        <div>1 ‚Äî Floor (walkable)</div>
        <div>2 ‚Äî Wall (solid)</div>
        <div>0 ‚Äî Erase (void)</div>
        <div>B ‚Äî Paint brush</div>
        <div>F ‚Äî Flood fill</div>
        <div>R ‚Äî Rectangle</div>
        <div>Drag ‚Äî Multi-paint</div>
      </div>

    </div>
  </div>

  <!-- Load Modal -->
  <div class="modal-overlay" id="loadModal">
    <div class="modal">
      <h2>üìÇ Load Map</h2>
      <ul class="modal-list" id="mapList"></ul>
      <button class="modal-close" onclick="hideLoadModal()">Cancel</button>
    </div>
  </div>

  <script>
    // ============================================================
    // STATE
    // ============================================================
    let mapWidth = 35, mapHeight = 22;

    // tiles[y][x]: 'floor' | 'solid' | null (void/erased)
    let tiles = [];

    let selectedMode = 'floor';     // 'floor' | 'solid' | 'erase'
    let selectedSpecial = null;     // 'start' | 'exit' | 'enemy' | null
    let currentTool = 'paint';
    let isDrawing = false;
    let rectStart = null;
    let undoStack = [], redoStack = [];

    let playerStart = null;
    let exitPortal = null;
    let enemySpawns = [];

    let uploadedImage = null;
    let uploadedImageCanvas = null;

    const CELL = 28;   // grid cell size in screen pixels
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    const miniCanvas = document.getElementById('minimapCanvas');
    const miniCtx = miniCanvas.getContext('2d');

    // ============================================================
    // IMAGE UPLOAD & AUTO-TRACE
    // ============================================================
    window.handleMapImageUpload = function (event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (e) {
        const img = new Image();
        img.onload = function () {
          uploadedImage = img;

          // Off-screen canvas for pixel sampling
          uploadedImageCanvas = document.createElement('canvas');
          uploadedImageCanvas.width = img.width;
          uploadedImageCanvas.height = img.height;
          uploadedImageCanvas.getContext('2d').drawImage(img, 0, 0);

          // Keep current grid size ‚Äî image scales to fit
          initMapAsWalls();
          resizeCanvas();

          document.getElementById('traceBtn').style.display = 'block';
          setStatus(`Image loaded: ${img.width}√ó${img.height}. Auto-tracing with threshold 128‚Ä¶`);

          traceFromImage();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    };

    function initMapAsWalls() {
      tiles = [];
      for (let y = 0; y < mapHeight; y++) {
        tiles[y] = [];
        for (let x = 0; x < mapWidth; x++) tiles[y][x] = 'solid';
      }
      playerStart = null;
      exitPortal = null;
      enemySpawns = [];
      undoStack = [];
      redoStack = [];
    }

    // Sample average brightness of image region mapped to grid cell (x, y)
    function getCellBrightness(x, y) {
      if (!uploadedImageCanvas) return 0;
      const uc = uploadedImageCanvas;
      const scaleX = uc.width / mapWidth;
      const scaleY = uc.height / mapHeight;
      const px = Math.min(Math.floor(x * scaleX), uc.width - 1);
      const py = Math.min(Math.floor(y * scaleY), uc.height - 1);
      const d = uc.getContext('2d').getImageData(px, py, 1, 1).data;
      return (d[0] + d[1] + d[2]) / 3;
    }

    window.traceFromImage = function () {
      if (!uploadedImageCanvas) return;
      const threshold = parseInt(document.getElementById('traceThreshold').value) || 128;
      document.getElementById('thresholdVal').textContent = threshold;
      saveState();
      for (let y = 0; y < mapHeight; y++)
        for (let x = 0; x < mapWidth; x++)
          tiles[y][x] = getCellBrightness(x, y) >= threshold ? 'floor' : 'solid';
      render();
      setStatus(`Auto-traced at threshold ${threshold}. Paint to fine-tune.`);
    };

    window.updateTracePreview = function () {
      const threshold = parseInt(document.getElementById('traceThreshold').value) || 128;
      document.getElementById('thresholdVal').textContent = threshold;
      if (uploadedImageCanvas) traceFromImage();
    };

    // ============================================================
    // INIT / RESIZE
    // ============================================================
    function initMap() {
      tiles = [];
      for (let y = 0; y < mapHeight; y++) {
        tiles[y] = [];
        for (let x = 0; x < mapWidth; x++) {
          // Border = wall, interior = floor
          tiles[y][x] = (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1)
            ? 'solid' : 'floor';
        }
      }
      playerStart = { x: 2, y: 2 };
      exitPortal = { x: mapWidth - 3, y: mapHeight - 3 };
      enemySpawns = [];
      undoStack = [];
      redoStack = [];
      resizeCanvas();
      render();
    }

    function resizeMap() {
      const [w, h] = document.getElementById('mapSize').value.split(',').map(Number);
      mapWidth = w;
      mapHeight = h;
      if (uploadedImage) {
        initMapAsWalls();
        resizeCanvas();
        traceFromImage();
      } else {
        initMap();
      }
      setStatus(`Grid: ${w}√ó${h}`);
    }

    function resizeCanvas() {
      canvas.width = mapWidth * CELL;
      canvas.height = mapHeight * CELL;
      miniCanvas.width = mapWidth;
      miniCanvas.height = mapHeight;
      render();
    }

    // ============================================================
    // RENDER
    // ============================================================
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 1. Background: uploaded image or dark fill
      if (uploadedImage) {
        ctx.drawImage(uploadedImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#0d0d1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // 2. Walkability overlay per cell
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          const t = tiles[y][x];
          const cx = x * CELL, cy = y * CELL;

          if (t === null) {
            // Void: fully black
            ctx.fillStyle = '#000';
            ctx.fillRect(cx, cy, CELL, CELL);
          } else if (t === 'solid') {
            // Wall: semi-transparent dark overlay ‚Äî image shows through dimly
            ctx.fillStyle = uploadedImage ? 'rgba(10,5,20,0.62)' : '#16121f';
            ctx.fillRect(cx, cy, CELL, CELL);
          }
          // Floor: no overlay ‚Äî image (or base colour) shows through fully
          // Slight tint when no image so floors are visible
          if (!uploadedImage && t === 'floor') {
            ctx.fillStyle = '#3a3228';
            ctx.fillRect(cx, cy, CELL, CELL);
          }

          // Grid lines
          ctx.strokeStyle = t === 'floor'
            ? 'rgba(80,200,80,0.1)'
            : 'rgba(255,255,255,0.04)';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(cx, cy, CELL, CELL);
        }
      }

      // 3. Special markers
      function drawMarker(pos, emoji, color) {
        if (!pos) return;
        const cx = pos.x * CELL + CELL / 2;
        const cy = pos.y * CELL + CELL / 2;
        ctx.beginPath();
        ctx.arc(cx, cy, CELL / 3, 0, Math.PI * 2);
        ctx.fillStyle = color + '55';
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = `${Math.round(CELL * 0.5)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, cx, cy);
      }
      enemySpawns.forEach(s => drawMarker(s, 'üëπ', '#cc2222'));
      drawMarker(playerStart, 'üü¢', '#00cc44');
      drawMarker(exitPortal, 'üåÄ', '#4488ff');

      renderMinimap();
      updateStats();
    }

    function renderMinimap() {
      const d = miniCtx.createImageData(mapWidth, mapHeight);
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          const t = tiles[y][x];
          let r = 8, g = 8, b = 18;
          if (t === 'floor') { r = 120; g = 105; b = 80; }
          else if (t === 'solid') { r = 30; g = 25; b = 40; }
          const i = (y * mapWidth + x) * 4;
          d.data[i] = r; d.data[i + 1] = g; d.data[i + 2] = b; d.data[i + 3] = 255;
        }
      }
      miniCtx.putImageData(d, 0, 0);
      if (playerStart) {
        miniCtx.fillStyle = '#00ff44';
        miniCtx.fillRect(playerStart.x, playerStart.y, 1, 1);
      }
      if (exitPortal) {
        miniCtx.fillStyle = '#4488ff';
        miniCtx.fillRect(exitPortal.x, exitPortal.y, 1, 1);
      }
      enemySpawns.forEach(s => {
        miniCtx.fillStyle = '#ff2222';
        miniCtx.fillRect(s.x, s.y, 1, 1);
      });
    }

    function updateStats() {
      let floors = 0;
      for (let y = 0; y < mapHeight; y++)
        for (let x = 0; x < mapWidth; x++)
          if (tiles[y][x] === 'floor') floors++;
      document.getElementById('statsSize').textContent = `${mapWidth}√ó${mapHeight}`;
      document.getElementById('statsFloors').textContent = floors;
      document.getElementById('statsStart').textContent = playerStart ? `(${playerStart.x},${playerStart.y})` : '‚ùå';
      document.getElementById('statsExit').textContent = exitPortal ? `(${exitPortal.x},${exitPortal.y})` : '‚ùå';
      document.getElementById('statsEnemies').textContent = enemySpawns.length;
    }

    // ============================================================
    // MODE & TOOL SELECTION
    // ============================================================
    function selectMode(mode) {
      selectedMode = mode;
      selectedSpecial = null;
      // Clear all active states then set the right one
      document.querySelectorAll('.tile-btn').forEach(b => b.classList.remove('active'));
      const map = { floor: 'btnFloor', solid: 'btnSolid', erase: 'btnErase' };
      document.getElementById(map[mode])?.classList.add('active');
      document.getElementById('infoMode').textContent = mode;
      setStatus(`Painting: ${mode}`);
    }

    function selectSpecial(type) {
      selectedSpecial = type;
      document.querySelectorAll('.tile-btn').forEach(b => b.classList.remove('active'));
      document.querySelector(`[data-special="${type}"]`)?.classList.add('active');
      document.getElementById('infoMode').textContent = type + ' marker';
      setStatus(`Placing: ${type} marker ‚Äî click on canvas`);
    }

    function setTool(tool) {
      currentTool = tool;
      document.querySelectorAll('[data-tool]').forEach(b => b.classList.toggle('active', b.dataset.tool === tool));
      document.getElementById('infoTool').textContent = tool;
    }

    // ============================================================
    // UNDO / REDO
    // ============================================================
    function saveState() {
      undoStack.push({
        tiles: tiles.map(r => [...r]),
        playerStart: playerStart ? { ...playerStart } : null,
        exitPortal: exitPortal ? { ...exitPortal } : null,
        enemySpawns: enemySpawns.map(s => ({ ...s })),
      });
      if (undoStack.length > 60) undoStack.shift();
      redoStack = [];
    }

    function undo() {
      if (!undoStack.length) return;
      redoStack.push(snapshot());
      const s = undoStack.pop();
      restore(s);
      render();
    }

    function redo() {
      if (!redoStack.length) return;
      undoStack.push(snapshot());
      const s = redoStack.pop();
      restore(s);
      render();
    }

    function snapshot() {
      return {
        tiles: tiles.map(r => [...r]),
        playerStart: playerStart ? { ...playerStart } : null,
        exitPortal: exitPortal ? { ...exitPortal } : null,
        enemySpawns: enemySpawns.map(s => ({ ...s })),
      };
    }

    function restore(s) {
      tiles = s.tiles;
      playerStart = s.playerStart;
      exitPortal = s.exitPortal;
      enemySpawns = s.enemySpawns;
    }

    // ============================================================
    // PAINTING
    // ============================================================
    function getGridPos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: Math.max(0, Math.min(Math.floor((e.clientX - rect.left) / CELL), mapWidth - 1)),
        y: Math.max(0, Math.min(Math.floor((e.clientY - rect.top) / CELL), mapHeight - 1)),
      };
    }

    function placeTile(x, y) {
      if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return;

      if (selectedSpecial === 'start') { playerStart = { x, y }; render(); return; }
      if (selectedSpecial === 'exit') { exitPortal = { x, y }; render(); return; }
      if (selectedSpecial === 'enemy') {
        const idx = enemySpawns.findIndex(s => s.x === x && s.y === y);
        if (idx >= 0) enemySpawns.splice(idx, 1);
        else enemySpawns.push({ x, y });
        render();
        return;
      }

      tiles[y][x] = selectedMode === 'erase' ? null : selectedMode;
    }

    function floodFill(sx, sy) {
      if (selectedSpecial) return;
      const fill = selectedMode === 'erase' ? null : selectedMode;
      const target = tiles[sy][sx];
      if (target === fill) return;

      const stack = [[sx, sy]];
      const visited = new Set();
      while (stack.length) {
        const [x, y] = stack.pop();
        if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) continue;
        const key = x + ',' + y;
        if (visited.has(key) || tiles[y][x] !== target) continue;
        visited.add(key);
        tiles[y][x] = fill;
        stack.push([x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]);
      }
    }

    canvas.addEventListener('mousedown', e => {
      const pos = getGridPos(e);
      saveState();
      isDrawing = true;
      if (currentTool === 'paint') { placeTile(pos.x, pos.y); render(); }
      else if (currentTool === 'fill') { floodFill(pos.x, pos.y); render(); isDrawing = false; }
      else if (currentTool === 'rect') { rectStart = pos; }
      setStatus(`(${pos.x}, ${pos.y})`);
    });

    canvas.addEventListener('mousemove', e => {
      const pos = getGridPos(e);
      if (isDrawing && currentTool === 'paint') { placeTile(pos.x, pos.y); render(); }
      const t = tiles[pos.y]?.[pos.x];
      setStatus(`(${pos.x}, ${pos.y}) ‚Äî ${t ?? 'void'}`);
    });

    canvas.addEventListener('mouseup', e => {
      if (isDrawing && currentTool === 'rect' && rectStart) {
        const pos = getGridPos(e);
        const x1 = Math.min(rectStart.x, pos.x), y1 = Math.min(rectStart.y, pos.y);
        const x2 = Math.max(rectStart.x, pos.x), y2 = Math.max(rectStart.y, pos.y);
        const fill = selectedMode === 'erase' ? null : selectedMode;
        for (let y = y1; y <= y2; y++)
          for (let x = x1; x <= x2; x++)
            tiles[y][x] = fill;
        render();
      }
      isDrawing = false;
      rectStart = null;
    });

    canvas.addEventListener('mouseleave', () => { isDrawing = false; rectStart = null; });

    // ============================================================
    // KEYBOARD
    // ============================================================
    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); return; }
      if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); return; }
      if (e.key === '1') selectMode('floor');
      if (e.key === '2') selectMode('solid');
      if (e.key === '0') selectMode('erase');
      if (e.key === 'b') setTool('paint');
      if (e.key === 'f') setTool('fill');
      if (e.key === 'r') setTool('rect');
    });

    // ============================================================
    // SAVE / LOAD
    // ============================================================
    async function saveMap() {
      if (!playerStart) { setStatus('‚ùå Place a Player Start first!'); return; }
      if (!exitPortal) { setStatus('‚ùå Place an Exit Portal first!'); return; }

      const worldId = parseInt(document.getElementById('worldId').value);
      const name = document.getElementById('mapName').value;
      const filename = `world_${worldId}_level_1.json`;

      // Boolean walkable grid: true = floor, false = wall/void
      const walkable = tiles.map(row => row.map(t => t === 'floor'));

      // Embed the uploaded image as base64 PNG
      let imageData = null;
      if (uploadedImage) {
        const tmp = document.createElement('canvas');
        tmp.width = uploadedImage.naturalWidth;
        tmp.height = uploadedImage.naturalHeight;
        tmp.getContext('2d').drawImage(uploadedImage, 0, 0);
        imageData = tmp.toDataURL('image/png');
      }

      const mapData = {
        version: 3,
        filename, name, world_id: worldId,
        width: mapWidth, height: mapHeight,
        player_start: [playerStart.x, playerStart.y],
        exit_portal: [exitPortal.x, exitPortal.y],
        enemy_spawns: enemySpawns.map(s => [s.x, s.y]),
        walkable,
        image_data: imageData,
      };

      setStatus('Saving‚Ä¶');
      try {
        const resp = await fetch('/save-map', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(mapData),
        });
        const result = await resp.json();
        if (result.success) setStatus(`‚úÖ Saved ${filename}`);
        else setStatus(`‚ùå Save failed: ${result.error}`);
      } catch (err) {
        setStatus(`‚ùå Server error: ${err.message}`);
      }
    }

    async function showLoadModal() {
      try {
        const resp = await fetch('/list-maps');
        const maps = await resp.json();
        const list = document.getElementById('mapList');
        list.innerHTML = maps.length === 0
          ? '<li style="color:#666">No saved maps</li>'
          : '';
        maps.forEach(m => {
          const li = document.createElement('li');
          li.textContent = `${m.name || m.filename} (${m.width}√ó${m.height}) ‚Äî World ${m.world_id}`;
          li.onclick = () => loadMap(m.filename);
          list.appendChild(li);
        });
        document.getElementById('loadModal').classList.add('show');
      } catch (err) {
        setStatus(`‚ùå ${err.message}`);
      }
    }

    function hideLoadModal() {
      document.getElementById('loadModal').classList.remove('show');
    }

    async function loadMap(filename) {
      hideLoadModal();
      try {
        const resp = await fetch(`/load-map?file=${filename}`);
        const data = await resp.json();
        mapWidth = data.width;
        mapHeight = data.height;

        if (data.version >= 3 && data.walkable) {
          // V3: boolean walkable grid
          tiles = data.walkable.map(row => row.map(w => w ? 'floor' : 'solid'));
        } else if (data.tiles) {
          // Legacy v1/v2: convert old tile format to floor/solid
          tiles = data.tiles.map(row => row.map(t => {
            if (t === 0 || t === null) return null;
            if (Array.isArray(t)) {
              const func = t[2];
              return (func === 1 || func === 5) ? 'floor' : 'solid';
            }
            if (typeof t === 'number') {
              return [1, 8, 9, 10, 11, 12, 13, 16, 17].includes(t) ? 'solid' : 'floor';
            }
            return null;
          }));
        }

        playerStart = data.player_start ? { x: data.player_start[0], y: data.player_start[1] } : null;
        exitPortal = data.exit_portal ? { x: data.exit_portal[0], y: data.exit_portal[1] } : null;
        enemySpawns = (data.enemy_spawns || []).map(s => ({ x: s[0], y: s[1] }));

        document.getElementById('mapName').value = data.name || '';
        document.getElementById('worldId').value = data.world_id || 0;

        undoStack = [];
        redoStack = [];

        // Restore embedded image if present
        if (data.image_data) {
          const img = new Image();
          img.onload = function () {
            uploadedImage = img;
            uploadedImageCanvas = document.createElement('canvas');
            uploadedImageCanvas.width = img.width;
            uploadedImageCanvas.height = img.height;
            uploadedImageCanvas.getContext('2d').drawImage(img, 0, 0);
            document.getElementById('traceBtn').style.display = 'block';
            resizeCanvas();
          };
          img.src = data.image_data;
        } else {
          uploadedImage = null;
          uploadedImageCanvas = null;
          resizeCanvas();
        }

        setStatus(`‚úÖ Loaded ${filename}`);
      } catch (err) {
        setStatus(`‚ùå Load failed: ${err.message}`);
      }
    }

    function setStatus(msg) {
      document.getElementById('statusBar').textContent = msg;
    }

    // ============================================================
    // START
    // ============================================================
    initMap();
  </script>

</body>
</html>
